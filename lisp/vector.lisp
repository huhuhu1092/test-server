(defgeneric vector-add (v1 v2) (:documentation "add two vector"))
(defgeneric vector-dot (v1 v2) (:documentation "two vector dot product"))
(defgeneric vector-cross (v1 v2) (:documentation "two vector cross product"))
(defgeneric vector-scalar-mul (v f) (:documentation "scalar multiply vector"))
(defgeneric vector-length (v) (:documentation "vector length"))
(defgeneric vector-length-square (v) (:documentation "vector length square"))
(defun get-classname (dimension type)
  (cond
   ((and (= dimension 2) (eql type :float)) 'vector2f)
   ((and (= dimension 2) (eql type :integer)) 'vector2i)
   ((and (= dimension 3) (eql type :float)) 'vector3f)
   ((and (= dimension 3) (eql type :integer)) 'vector3i)
   ((and (= dimension 4) (eql type :float)) 'vector4f)
   ((and (= dimension 4) (eql type :integer)) 'vector4i)
   (t (error "dimension type error"))
   )
  )
(defun get-vector-component (dimension)
  (cond ((= dimension 2) '(x y))
	((= dimension 3) '(x y z))
	((= dimension 4) '(x y z w))
	(t (error "dimension error")))
  )
(defmacro defvector (dimension data-type)
  (let* ((type (if (eql data-type 'f) :float :integer))
	(components (get-vector-component dimension))
	(class-name (get-classname dimension type))
	(x (car components))
	(y (cadr components))
	(z (caddr components))
	(w (cadddr components))
	)
    `(defclass ,class-name () ((,x :initarg :x :initform 0 :accessor vector-x :type ,type)
			    (,y :initarg :y :initform 0 :accessor vector-y :type ,type)
			    ,@(if (not (eql z nil)) `((,z :initarg :z :initform 0 :accessor vector-z :type ,type)) nil)
			    ,@(if (not (eql w nil)) `((,w :initarg :w :initform 0 :accessor vector-w :type ,type)) nil)))
    )
  )
(defvector 2 i)
(defvector 3 i)
(defvector 4 i)
(defvector 2 f)
(defvector 3 f)
(defvector 4 f)
(defmethod vector-add ((v1 vector2f) (v2 vector2f))
  (make-instance 'vector2f :x (+ (vector-x v1) (vector-x v2)) :y (+ (vector-y v1) (vector-y v2)))
  )
(defmethod vector-add ((v1 vector2f) (v2 vector3f))
  (make-instance 'vector3f :x (+ (vector-x vt) (vector-x v2)) :y (+ (vector-y vt) (vector-y v2)) :z (vector-z v2))
  )
;;test case
(setf v1 (make-instance 'vector2f :x 0 :y 1))
(setf v2 (make-instance 'vector2f :x 1.0 :y 2))
(setf vc (vector-add v1 v2))