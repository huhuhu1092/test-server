(defgeneric vector-add (v1 v2) (:documentation "add two vector"))
(defgeneric vector-sub (v1 v2) (:documentation "subtract two vector"))
(defgeneric vector-dot (v1 v2) (:documentation "two vector dot product"))
(defgeneric vector-cross (v1 v2) (:documentation "two vector cross product"))
(defgeneric vector-scalar-mul (v f) (:documentation "scalar multiply vector"))
(defgeneric vector-length (v) (:documentation "vector length"))
(defgeneric vector-length-square (v) (:documentation "vector length square"))
(defun get-classname (dimension type)
  (cond
   ((and (= dimension 2) (eql type :float)) 'vector2f)
   ((and (= dimension 2) (eql type :integer)) 'vector2i)
   ((and (= dimension 3) (eql type :float)) 'vector3f)
   ((and (= dimension 3) (eql type :integer)) 'vector3i)
   ((and (= dimension 4) (eql type :float)) 'vector4f)
   ((and (= dimension 4) (eql type :integer)) 'vector4i)
   (t (error "dimension type error"))
   )
  )
(defun get-vector-component (dimension)
  ;;(format t "dimension : ~a~%" dimension)
  (cond ((= dimension 2) '(x y))
	((= dimension 3) '(x y z))
	((= dimension 4) '(x y z w))
	(t (error "dimension error")))
  )
(defmacro defvector (dimension data-type)
  (let* ((type (if (eql data-type 'f) :float :integer))
	(components (get-vector-component dimension))
	(class-name (get-classname dimension type))
	(x (car components))
	(y (cadr components))
	(z (caddr components))
	(w (cadddr components))
	)
    `(defclass ,class-name () ((,x :initarg :x :initform 0 :accessor vector-x :type ,type)
			    (,y :initarg :y :initform 0 :accessor vector-y :type ,type)
			    ,@(if (not (eql z nil)) `((,z :initarg :z :initform 0 :accessor vector-z :type ,type)) nil)
			    ,@(if (not (eql w nil)) `((,w :initarg :w :initform 0 :accessor vector-w :type ,type)) nil)))
    )
  )
(defvector 2 i)
(defvector 3 i)
(defvector 4 i)
(defvector 2 f)
(defvector 3 f)
(defvector 4 f)
(defmacro vector-op (d1 t1 v1 d2 t2 v2 op)
  (let* ((d (if (> d1 d2) d1 d2))
	 (type (if (some #'(lambda (x) (eql x 'f)) (list t1 t2)) :float :integer))
         (class-name (get-classname d type))
	 )
    `(make-instance ',class-name :x (,op (vector-x ,v1) (vector-x ,v2)) :y (,op (vector-y ,v1) (vector-y ,v2))
		    ,@(if (>= d 3 ) (cond ((and (= d1 d) (= d2 d)) `(:z (vector-z ,v1) (vector-z ,v2)))
					  ((= d1 d) `(:z (vector-z ,v1)))
					  ((= d2 d) `(:z (vector-z ,v2)))
					  ) nil)
		    ,@(if (= d 4) (cond ((and (= d1 d) (= d2 d)) `(:w (vector-w ,v1) (vector-w ,v2)))
					  ((= d1 d) `(:w (vector-w ,v1)))
					  ((= d2 d) `(:w (vector-w ,v2)))
					  ) nil))
    )
  )
(defmethod vector-add ((v1 vector2f) (v2 vector2f))
  (vector-op 2 f v1 2 f v2 +)
  )
(defmethod vector-add ((v1 vector2f) (v2 vector3f))
  (vector-op 2 f v1 3 f v2 +)
  )
(defmethod vector-add ((v1 vector3f) (v2 vector2f))
  (vector-op 3 f v1 2 f v2 +)
  )
(defmethod vector-add ((v1 vector2f) (v2 vector4f))
  (vector-op 2 f v1 4 f v2 +)
  )
(defmethod vector-add ((v1 vector3f) (v2 vector4f))
  (vector-op 3 f v1 4 f v2 +)
  )
(defmethod vector-add ((v1 vector4f) (v2 vector3f))
  (vector-op 4 f v1 3 f v2 +)
  )
(defmethod vector-add ((v1 vector3f) (v2 vector3f))
  (vector-op 3 f v1 3 f v2 +)
  )
(defmethod vector-add ((v1 vector4f) (v2 vector4f))
  (vector-op 4 f v1 4 f v2 +)
  )
(defmethod vector-sub
;;test case
(setf v1 (make-instance 'vector2f :x 0 :y 1))
(setf v2 (make-instance 'vector2f :x 1.0 :y 2))
(setf v3 (make-instance 'vector3f :x 3 :y 5 :z 4))
(setf v4 (make-instance 'vector3i :x 4 :y 6 :z 8))
(setf v5 (make-instance 'vector4f :x 8 :y 9 :z 10 :w 34))
(setf v6 (make-instance 'vector4i :x 7 :y 0 :z 1 :w 3))
(vector-add v3 v5)
;;(setf vc (vector-add v1 v2))
