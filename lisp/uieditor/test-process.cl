(defconstant +EXIT+ 0)
(defstruct xqueue
  data
  lock
  gate
  )
(defstruct xevent
  id
  data-len
  data
  )
(defstruct socket-rw-block
  read-queue
  write-queue
  sock
  )
;;tag is :read or :write
(defun enqueue (tag queue item)
  (cond ((eql tag :read)
	 (mp:with-process-lock ((xqueue-lock queue))
			       (setf (xqueue-data queue) (concatenate 'vector (xqueue-data queue) item)) 
			       )
	 )
	((eql tag :write)
	 (mp:with-process-lock ((xqueue-lock queue))
			       (setf (xqueue-data queue) (nconc (xqueue-data queue) (list item)))
			       (mp:open-gate (xqueue-gate queue))
			       )
	 )
	(t (error "tag is not :read or :write"))
	)
  )
(defun dequeue (tag queue)
  (cond ((eql tag :read)
	 (mp:with-process-lock ((xqueue-lock queue))
			       (multiple-value-bind (e newdata) (get-event (xqueue-data queue))
						    (setf (xqueue-data queue) newdata)
						    e
						    )
			       )
	 )
	((eql tag :write)
	 (mp:with-process-lock ((xqueue-lock queue))
			       (let ((e (pop (xqueue-data queue))))
				 (if (null (xqueue-data queue)) (mp:close-gate (xqueue-gate queue)))
				 e
				 
				 )
			       )
	 )
	(t (error "tag is not :read or write"))
	)
  )
(defun queue-null-p (queue)
  (mp:with-process-lock ((xqueue-lock queue))
			(null (xqueue-data queue))
			)
  )
(defun reader-process-fun (socket-block mainprocess)
    (loop (let* ((buffer (make-array 1024 :element-type '(unsigned-byte 8) :initial-element 0))
	      (len (read-sequence buffer (socket-rw-block-sock socket-block) :partial-fill t)))
	  (enqueue :read (socket-rw-block-read-queue socket-block) (subseq buffer 0 len))
	  )
	(let ((e (dequeue :read (socket-rw-block-read-queue socket-block))))
	  (when e
	    (let ((ret (handle-xevent e mainprocess)))
	      (if (= ret +EXIT+) (return))
		    )
		)
	  )
	)
    )
(defun writer-process-fun (socket-block mainprocess)
    (loop
    (if (queue-null-p (socket-rw-block-write-queue socket-block))
	(mp:process-wait "wait for write data" #'mp:gate-open-p (xqueue-gate (socket-rw-block-write-queue socket-block)))
      )
    (let* ((queue (socket-rw-block-write-queue socket-block))
	   (event (dequeue :write queue))
	   )
          (if (null event) (error "event is null"))
          (when (equal (xevent-id event) +EXIT+) (return))
	  (write-event (socket-rw-block-sock socket-block) event)
	   )
   )
  )
(defun reverse-tree (l)
  (cond ((null l) nil)
        ((atom l) l)
        (t (let ((first (reverse-tree (cdr l)))
                 (second (reverse-tree (car l))))
             (cond ((and (null first) (atom second)) (list second)) 
                   ((and (null first) (consp second)) (cons second nil))
                   ((not (null first)) (append first (list second)))
                   (t (error "can not go to here"))
		   )
	     )
	   )
	)
  )

(defun get-event (data)
  #+debug (format t "get-event: data len = ~a ~%" (length data))
  (let ((len (length data)))
    (if (< len 3)
	nil
      (let ((event-id (aref data 0))
	    (event-len1 (aref data 1))
	    (event-len2 (aref data 2))
	    (total-len 0)
	    )
	(setf (ldb (byte 8 8) total-len) event-len1)
	(setf (ldb (byte 8 0) total-len) event-len2)
	#+debug (format t "total len = ~a ~%" total-len)
	(when (< total-len 3) (error "data len less than 3"))
	#+debug (format t "data len = ~a ~%" total-len)
	(when (>= (length data) total-len) 
	  (let* ((data-len (- total-len 3))
	         (e (make-xevent :id event-id :data-len data-len :data (subseq data 3 total-len)))
		 )
	    (values e (subseq data total-len))
	    )
	  )
	  )
    )
    )
  )
(defun write-event (sock event)
  (let* ((total-len (+ (xevent-data-len event) 3))
	(header (make-array 3 :element-type '(unsigned-byte 8) :initial-element 0))
	(len-net (HostToNetShort total-len))
	)
    #+debug (format t "##write total len = ~a ~%" total-len)
    (setf (aref header 0) (xevent-id event))
    (setf (aref header 1) (ldb (byte 8 0) len-net))
    (setf (aref header 2) (ldb (byte 8 8) len-net))
    (let ((data (concatenate 'vector header (xevent-data event))))
      (print data)
      (write-sequence data sock)
      (force-output sock)
      )
    )
  )
(defun handle-xevent (event mainprocess)
  (let ((id (xevent-id event)))
    (cond ((= id 0) +EXIT+)
	  (t (format *terminal-io* "event id = ~a ~%" id) id)
	  )
    )
  )
(defun create-reader-process (name sock mainprocess)
  (let ((sr (make-socket-reader :sock sock
				:queue (make-xqueue :data nil :lock (mp:make-process-lock) :gate (mp:make-gate nil)))))
    (mp:process-run-function name #'reader-process-fun sr mainprocess)
    )
  )

(defun read-data-from-socket (sock)
  (let* ((buffer (make-array 1024 :element-type '(unsigned-byte 8) :initial-element 0))
	 (num (read-sequence buffer sock))
	 )
      (subseq buffer 0 num)
    )
  )
(defparameter *sock-block* nil)
(defun connect-to-tcp-server (server-ip server-port)
    (mp:process-run-function "createsocketreader" #'(lambda (ip port)
						      (let ((s (socket:with-pending-connect
								(sys:with-timeout (10 (error "connect failed"))
										  (socket:make-socket :remote-host server-ip
												      :remote-port server-port
												      :type :stream
												      :address-family :internet)))))
							(setf *sock-block* (make-socket-rw-block :sock s :read-queue (make-xqueue :data nil :lock (mp:make-process-lock :name "readlock") :gate (mp:make-gate nil)) :write-queue (make-xqueue :data nil :lock (mp:make-process-lock :name "writelock") :gate (mp:make-gate nil))))
			
							#+debug (format t "create socket reader ~%")
							(create-reader-process "socketreader" *sock-block* nil)
							(create-writer-process "socketwriter" *sock-block* nil)
							)
						      )
			     server-ip
			     server-port
			     )
  )
(defun test-connect  (server-ip server-port)
  (let* ((s (socket:with-pending-connect
	    (sys:with-timeout (10 (error "connect failed"))
			      (socket:make-socket :remote-host server-ip
						  :remote-port server-port
						  :type :stream
						  :address-family :internet))))
	 )
    (setf *sock-block* (make-socket-rw-block :sock s :read-queue (make-xqueue :data nil :lock (mp:make-process-lock :name "readlock") :gate (mp:make-gate nil)) :write-queue (make-xqueue :data nil :lock (mp:make-process-lock :name "writelock") :gate (mp:make-gate nil))))
    (enqueue :write (socket-rw-block-write-queue *sock-block*) (make-xevent :id 1 :data-len 2 :data "aa"))
    (writer-process-fun *sock-block* nil)
    )
  )