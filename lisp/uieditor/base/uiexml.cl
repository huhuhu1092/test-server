(in-package :uie)
(defstruct imagetable id imageitems)
(defstruct imageitem id image-file-path mirror images)
(defstruct image id x y width height mirror)
(defun parse-xml (xml-filename)
  (with-open-file
   (in xml-filename)
   (net.xml.parser:parse-xml in)
   )
  )
(defun group (source n)
  (if (zerop n) (error "zero length"))
  (labels ((rec (source acc)
		(let ((rest (nthcdr n source)))
		  (if (consp rest)
		      (rec rest (cons (subseq source 0 n) acc))
		    (nreverse (cons source acc))))))
	  (if source (rec source nil) nil)))
(defun parse-attribute (attr-list fn)
  (let ((pair-list (group attr-list 2)))
    (dolist (attr pair-list)
      (funcall fn attr)
      )
    )
  )
(defun imagetable-attr (attr)
  (when (eql (first attr) '|id|) (print (second attr)))
  )
(defun imageitem-attr (attr)
  (cond ((eql (first attr) '|id|) (print (second attr)))
	((eql (first attr) '|name|) (print (second attr)))
	((eql (first attr) '|mirror|) (print (second attr)))
	(t (print "error"))
	)
  )
(defun imagepiece-attr (attr)
  (cond ((eql (first attr) '|startx|) (print (second attr)))
	((eql (first attr) '|starty|) (print (second attr)))
	((eql (first attr) '|endx|) (print (second attr)))
	((eql (first attr) '|endy|) (print (second attr)))
	 )
  )
(defun test ()
  (with-open-file (out "C:\\testimage1.txt" :direction :output :if-exists :supersede)
  (with-standard-io-syntax
    (print (uie:parse-xml "C:\\ppp\\aa\\imagetable\\CharaterFaceImageDefine.xml") out))
  )
(with-open-file (in "C:\\testimage1.txt")
  (with-standard-io-syntax
    ;;(print (read in))
    (uie:parse-element-list (read in))
  ))
  )
(defun parse-element-list (element-list)
  (format t "~a ~%" element-list)
  (when (and (listp element-list) element-list)
    (let ((element-head (car element-list)))
      (if (consp element-head)
	  (parse-element-list element-head)
        (cond ((eql element-head '|ImageTable|) (parse-attribute (cdr element-list) #'imagetable-attr))
	      ((eql element-head '|ImageItem|)(parse-attribute (cdr element-list) #'imageitem-attr))
	      ((eql element-head '|Image|) (parse-attribute (cdr element-list) #'imagepiece-attr))
	      )
	)
        (parse-element-list (cdr element-list))
      )
    )
  )
(defun read-char-sequence (file-name)
  (with-open-file (in file-name :element-type '(unsigned-byte 8) :if-does-not-exist nil)
    (if (null in) nil
      (let* ((file-length (file-length in))
	     (content (make-array file-length)))
	(read-sequence content in)
	(let ((data (make-array file-length)))
	  (dotimes (i file-length) (setf (aref data i) (code-char (aref content i))))
	  data
	  )
	)
      )
    )
  )
(defvar *current-level* 0)
(defvar *in-comment* 0)
(defstruct element token level state)
(defstruct char-sequence content curr-index)
(defun is-end? (char-seq)
  (= (char-sequence-curr-index (length (char-sequence-content char-seq))))
  )
(defun readc (char-seq)
  (if (is-end? char-seq) nil
    (let ((ret (aref (char-sequence-content char-seq) (char-sequence-curr-index char-seq))))
      (incf (char-sequence-curr-index char-seq) 1)
      ret
      )
    )
  )
(defun whitespace-char? (c)
  (or (eql c nil) (char= c #\Space) (char= c #\Tab) (char= c #\Newline) (char= c #\Return))
  )
(defun get-token (char-seq)
  (while (whitespace-char? (readc char-seq)) nil)
  (let ((start (- (char-sequence-curr-index char-seq) 1)))
    (while (not (whitespace-char? (readc char-seq))))
    (let ((end (- (char-sequence-curr-index char-seq) 1)))
      (if (is-end? char-seq)
	  (subseq char-seq start (+ end 1))
	  (subseq char-seq start end))
      )
    )
  )
(defvar *xml-list* nil)
(defun create-xml-list (char-seq)
  (loop (when (is-end? char-seq) (return-from create-xml-list *xml-list*))
    (let ((curr-token (get-token char-seq)))
      (cond ((or (string= curr-token "<!--") (string= curr-token "<?")) (setf *in-comment* 1))
	    ((or (string= curr-token "-->") (string= curr-token "?>")) (setf *in-comment* 0))
	    ((string= curr-token "<") nil)
	
	)
      )
    )
  )

