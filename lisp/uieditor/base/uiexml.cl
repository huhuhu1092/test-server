(in-package :uie)
(defstruct imagetable id imageitems)
(defstruct imageitem id image-file-path mirror images)
(defstruct image id x y width height mirror)
(defvar *imagetablelist* nil)
(defvar *currimagetable* nil)
(defvar *currimageitem* nil)
;(defvar *currimage* nil)
(defun parse-xml (xml-filename)
  (with-open-file
   (in xml-filename)
   (net.xml.parser:parse-xml in)
   )
  )
(defun group (source n)
  (if (zerop n) (error "zero length"))
  (labels ((rec (source acc)
		(let ((rest (nthcdr n source)))
		  (if (consp rest)
		      (rec rest (cons (subseq source 0 n) acc))
		    (nreverse (cons source acc))))))
	  (if source (rec source nil) nil)))

(defun get-second (pair-list first)
  (dolist (pair pair-list)
    (if (string= (symbol-name (first pair)) first)
	(return-from get-second (second pair))
      )
    )
  nil
  )
(defun get-int (s)
  (parse-integer s)
  )
(defun parse-attribute (attr-list flag)
  #+debug (format t "attr: ~a ~%" attr-list)
  (let ((pair-list (group attr-list 2))
	(id nil)
	(name nil)
	(startx nil)
	(starty nil)
	(endx nil)
	(endy nil)
	(mirror nil)
	)
    (dolist (pair pair-list)
      (cond ((string= (symbol-name (first pair)) "id") (setf id (second pair)))
	    ((string= (symbol-name (first pair)) "name") (setf name (second pair)))
	    ((string= (symbol-name (first pair)) "startx") (setf startx (second pair)))
	    ((string= (symbol-name (first pair)) "starty") (setf starty (second pair)))
	    ((string= (symbol-name (first pair)) "endx") (setf endx (second pair)))   
	    ((string= (symbol-name (first pair)) "endy") (setf endy (second pair)))
	    ((string= (symbol-name (first pair)) "mirror") (setf mirror (second pair)))
	    (t (format t "need not: ~a ~%" (first pair)))
	    )
      )
    (cond ((eql flag :imagetable) (make-imagetable :id id :imageitems nil))
	  ((eql flag :imageitem) (make-imageitem :id id :image-file-path name
						 :mirror mirror :images nil))
	  ((eql flag :image) (make-image :id id :x (get-int startx) :y (get-int starty) :width (+ (- (get-int endx) (get-int startx)) 1) :height (+ (- (get-int endy) (get-int starty)) 1) :mirror mirror))
	  )
    )
  )
(defun clear-imagetablelist ()
  (setf *imagetablelist* nil)
  )
(defun get-image-item (id-list)
  (let* ((imagetable (find-if #'(lambda (i) (string= (car id-list) (imagetable-id i))) *imagetablelist*))
	(imageitem (find-if #'(lambda (i) (string= (cadr id-list) (imageitem-id i))) (imagetable-imageitems imagetable)))
	)
    imageitem
    )
  )
(defun get-image (id-list)
  (let ((item (get-image-item (subseq id-list 0 2))))
    (find-if #'(lambda (image) (string= (image-id image) (third id-list))) (imageitem-images item))
    )
  )
(defun parse-image-table (file-name)
  (uie:parse-element-list (uie:parse-xml file-name))
  (setf *imagetablelist* (nreverse *imagetablelist*))
  (dolist (imagetable *imagetablelist*)
    (let ((imageitems (imagetable-imageitems imagetable)))
      (setf (imagetable-imageitems imagetable) (nreverse imageitems))
      (let ((imageitems (imagetable-imageitems imagetable)))
        (dolist (imageitem imageitems)
	  (setf (imageitem-images imageitem) (nreverse (imageitem-images imageitem)))
	  )
        )
      )
    )
  *imagetablelist*
  ;; (with-open-file (out "D:\\testimage1.txt" :direction :output :if-exists :supersede)
  ;;   (with-standard-io-syntax
  ;;     (print (uie:parse-xml "D:\\model\\tmp\\aa\\imagetable\\CharaterFaceImageDefine.xml") out))
  ;; )
  ;; (with-open-file (in "D:\\testimage1.txt")
  ;;   (with-standard-io-syntax
  ;;     (uie:parse-element-list (read in))
  ;;     )
  ;;   )
)
(defun all-atomp (lst)
  (every #'(lambda (c) (atom c)) lst)
  )
(defun is-imagetable (e)
  (string= (symbol-name e) "ImageTable")
  )
(defun is-imageitem (e)
  (string= (symbol-name e) "ImageItem")
  )
(defun is-image (e)
  (string= (symbol-name e) "Image")
  )
(defun process-attribute (element-head attr-list)
  #+debug(format t "~a ~a ~a ~%" (type-of element-head) (symbol-name element-head) attr-list)
  (cond ((is-imagetable element-head)
	 (let ((instance (parse-attribute attr-list :imagetable)))
	   (if instance (progn (push instance *imagetablelist*) (setf *currimagetable* instance)))
	   )
	 )
	((is-imageitem element-head)
	 (let ((instance (parse-attribute attr-list :imageitem)))
	   (if instance (progn (push instance (imagetable-imageitems *currimagetable*)) (setf *currimageitem* instance)))
	   )
	 )
	((is-image element-head)
	 (let ((instance (parse-attribute attr-list :image)))
	   (if instance (progn (push instance (imageitem-images *currimageitem*))))
	   )
	 )
	(t (progn (format t "error element name~%") nil))
	)
  )
(defun parse-element-list (element-list)
  (dolist (element element-list)
    (if (listp element)
	(let ((element-head (car element)))
	  #+debug (format t "head: ~a ~%" element-head)
	  (if (atom element-head)
	      (if (all-atomp (cdr element))
		  (process-attribute element-head (cdr element))
		  (parse-element-list (cdr element))
		)
	      (parse-element-list element)
	    )
	  )
      )
    )
  )
(defun read-char-sequence (file-name)
  (with-open-file (in file-name :element-type '(unsigned-byte 8) :if-does-not-exist nil)
    (if (null in) nil
      (let* ((file-length (file-length in))
	     (content (make-array file-length)))
	(read-sequence content in)
	(let ((data (make-array file-length)))
	  (dotimes (i file-length) (setf (aref data i) (code-char (aref content i))))
	  data
	  )
	)
      )
    )
  )
(defvar *current-level* 0)
(defvar *in-comment* 0)
(defstruct element token level state)
(defstruct char-sequence content curr-index)
(defun is-end? (char-seq)
  (= (char-sequence-curr-index (length (char-sequence-content char-seq))))
  )
(defun readc (char-seq)
  (if (is-end? char-seq) nil
    (let ((ret (aref (char-sequence-content char-seq) (char-sequence-curr-index char-seq))))
      (incf (char-sequence-curr-index char-seq) 1)
      ret
      )
    )
  )
(defun whitespace-char? (c)
  (or (eql c nil) (char= c #\Space) (char= c #\Tab) (char= c #\Newline) (char= c #\Return))
  )
(defun get-token (char-seq)
  (while (whitespace-char? (readc char-seq)) nil)
  (let ((start (- (char-sequence-curr-index char-seq) 1)))
    (while (not (whitespace-char? (readc char-seq))))
    (let ((end (- (char-sequence-curr-index char-seq) 1)))
      (if (is-end? char-seq)
	  (subseq char-seq start (+ end 1))
	  (subseq char-seq start end))
      )
    )
  )
(defvar *xml-list* nil)
(defun create-xml-list (char-seq)
  (loop (when (is-end? char-seq) (return-from create-xml-list *xml-list*))
    (let ((curr-token (get-token char-seq)))
      (cond ((or (string= curr-token "<!--") (string= curr-token "<?")) (setf *in-comment* 1))
	    ((or (string= curr-token "-->") (string= curr-token "?>")) (setf *in-comment* 0))
	    ((string= curr-token "<") nil)
	
	)
      )
    )
  )

