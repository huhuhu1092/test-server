(in-package :uie)
(defconstant +component-define+ '((:element "element" "this is for element directory")
				  (:image "image" "this is for image directory")
				  (:imagetable  "imagetable" "this is for image table directory")
			          (:effect "effect" "this is for effect directory")
				  (:action "action" "this is for action directory")
				  (:statetable "statetable" "this is for state table directory")))
(defvar *projects* nil)
(defstruct project name path components)
(defstruct component
  dirname ;;dirname is keyword value
  dirvalue ;;dirvalue is string
  items
  comment ;;this component's usage  
  )
(defun component-define-name (cd)
  (car cd)
  )
(defun component-define-value (cd)
  (cadr cd)
  )
(defun component-define-comment (cd)
  (caddr cd)
  )

(defun create-project-component ()
  (mapcar #'(lambda (cd) (make-component :dirname (component-define-name cd)
					:dirvalue (component-define-value cd)
					:items nil
					:comment (component-define-comment cd)))
	  +component-define+)
  )

(defun add-project (name path)
  (when (find-project name path) (error "project's has contained"))
  (let ((project (make-project :name name :path path :components (create-project-component)))) 
    (pushnew project *projects*)
    (setf *projects* (nreverse *projects*))
    )
  )
(defun delete-project (name path)
  (let ((p (remove-if #'(lambda (p) (and (string= (project-name p) name) (string= (project-path p) path))) *projects*)))
    (setf *projects* p)
    )
  )

(defun get-all-project ()
  (copy-list *projects*)
  )
(defmacro find-project-by (flag str1 &rest str2)
  (cond ((eql flag :name) `(remove-if-not #'(lambda (p) (string= (project-name p) ,str1)) *projects*))
	((eql flag :path) `(remove-if-not #'(lambda (p) (string= (project-path p) ,str1)) *projects*))
	((eql flag :name-path) `(remove-if-not #'(lambda (p) (and (string= (project-name p) ,str1) (string= (project-path p) ,(car str2)))) *projects*))
	(t (error "flag is not support")))
  )
(defun find-project-by-name (name)
  "
      return the project list whose name is equal to name
  "
     (find-project-by :name name)
  )
(defun find-project-by-path (path)
  (find-project-by :path path)
  )
(defun find-project (name path)
  (car (find-project-by :name-path name path))
  )
(defmacro get-component (fn projects)
  ;;`(mapcar #'(lambda (p) (funcall ,fn p)) projects)
  (let ((name (gensym))
	(p (gensym)))
    `(let ((,name nil))
       (dolist (,p ,projects)
	 (pushnew (funcall ,fn ,p) ,name)
	 )
       (reverse ,name)
       )
    )
  )
(defun get-project-path-with-name (name)
  (let ((projects (find-project-by-name name)))
    (get-component #'project-path projects)
    )
  )
(defun get-project-name-with-path (path)
  (let ((projects (find-project-by-path path)))
    (get-component #'project-name projects)
    )
  )
(defun get-all-project-name ()
  (get-component #'project-name *projects*)
  )
(defun get-all-project-path ()
  (get-component #'project-path *projects*)
  )
(defun project-num ()
  (length *projects*)
  )

(defun component-value-and-comment (p)
  (let ((components (project-components p)))
    (mapcar #'(lambda (c) (cons (component-dirvalue c) (component-comment c))) components)
    )
  )
(defun get-project-name (p)
  (project-name p)
  )
(defun get-project-path (p)
  (project-path p)
  )
(defun clear-project (p)
  )
(defun clear-all-project ()
  (dolist (p *projects*)
    (clear-project p)
    )
  (setf *projects* nil)
  )

