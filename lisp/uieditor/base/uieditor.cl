(in-package :uie)
(defconstant +component-define+ '((:element "element" "this is for element directory")
				  (:image "image" "this is for image directory")
				  (:imagetable  "imagetable" "this is for image table directory")
			          (:effect "effect" "this is for effect directory")
				  (:action "action" "this is for action directory")
				  (:statetable "statetable" "this is for state table directory")))
(defvar *projects* nil)

(defstruct project-manager projects curr-project)
(defstruct project name path components)
(defstruct component
  dirname ;;dirname is keyword value
  dirvalue ;;dirvalue is string
  items
  comment ;;this component's usage  
  )
(defvar *project-manager* (make-project-manager :projects nil :curr-project nil))
(defun component-define-name (cd)
  (car cd)
  )
(defun component-define-value (cd)
  (cadr cd)
  )
(defun component-define-comment (cd)
  (caddr cd)
  )

(defun create-project-component ()
  (mapcar #'(lambda (cd) (make-component :dirname (component-define-name cd)
					:dirvalue (component-define-value cd)
					:items nil
					:comment (component-define-comment cd)))
	  +component-define+)
  )
(defun tokens (str test start)
  (let ((p1 (position-if test str :start start)))
    (if p1
	(let ((p2 (position-if #'(lambda (c) (not (funcall test c))) str :start p1)))
	  (cons (subseq str p1 p2) (if p2 (tokens str test p2) nil)))
      nil))
  )
(defun constituent(c)
  (and (graphic-char-p c) (not (char= c #\Space)))
  )
(defun add-project (name path)
  (when (find-project name path) (error "project's has contained"))
  (let ((project (make-project :name name :path path :components (create-project-component)))) 
    (pushnew project (project-manager-projects *project-manager*))
    (setf (project-manager-projects *project-manager*) (nreverse (project-manager-projects *project-manager*)))
    (add-to-filesystem name path)
    )
  )
(defun delete-project (name path)
  (let ((p (remove-if #'(lambda (p) (and (string= (project-name p) name) (string= (project-path p) path))) (project-manager-projects *project-manager*))))
    (setf (project-manager-projects *project-manager*) p)
    )
  )

(defun get-all-project ()
  (copy-list (project-manager-projects *project-manager*))
  )
(defmacro find-project-by (flag str1 &rest str2)
  (cond ((eql flag :name) `(remove-if-not #'(lambda (p) (string= (project-name p) ,str1)) (project-manager-projects *project-manager*)))
	((eql flag :path) `(remove-if-not #'(lambda (p) (string= (project-path p) ,str1)) (project-manager-projects *project-manager*)))
	((eql flag :name-path) `(remove-if-not #'(lambda (p) (and (string= (project-name p) ,str1) (string= (project-path p) ,(car str2)))) (project-manager-projects *project-manager*)))
	(t (error "flag is not support")))
  )
(defun find-project-by-name (name)
  "
      return the project list whose name is equal to name
  "
     (find-project-by :name name)
  )
(defun find-project-by-path (path)
  (find-project-by :path path)
  )
(defun find-project (name path)
  (car (find-project-by :name-path name path))
  )
(defmacro get-component (fn projects)
  ;;`(mapcar #'(lambda (p) (funcall ,fn p)) projects)
  (let ((name (gensym))
	(p (gensym))
	(ps (gensym)))
    `(let ((,name nil)
           (,ps ,projects)) 
       (dolist (,p ,ps)
	 (pushnew (funcall ,fn ,p) ,name)
	 )
       (reverse ,name)
       )
    )
  )
(defun get-project-path-with-name (name)
  (let ((projects (find-project-by-name name)))
    (get-component #'project-path projects)
    )
  )
(defun get-project-name-with-path (path)
  (let ((projects (find-project-by-path path)))
    (get-component #'project-name projects)
    )
  )
(defun get-all-project-name ()
  (get-component #'project-name (project-manager-projects *project-manager*))
  )
(defun get-all-project-path ()
  (get-component #'project-path (project-manager-projects *project-manager*))
  )
(defun get-all-project-name-path ()
  (mapcar #'(lambda (p) (cons (project-name p) (project-path p))) (project-manager-projects *project-manager*))
  )
(defun project-num ()
  (length (project-manager-projects *project-manager*))
  )

(defun component-value-and-comment (p)
  (let ((components (project-components p)))
    (mapcar #'(lambda (c) (cons (component-dirvalue c) (component-comment c))) components)
    )
  )
(defun get-curr-project ()
  (project-manager-curr-project *project-manager*)
  )
(defun set-curr-project (p)
  (setf (project-manager-curr-project *project-manager*) p)
  )
(defun get-project-name (p)
  (project-name p)
  )
(defun get-project-path (p)
  (project-path p)
  )
(defun delete-all-project ()
  (let ((ps (project-manager-projects *project-manager*)))
    (dolist (p ps)
      (delete-project (project-name p) (project-path p))
      )
    (setf (project-manager-projects *project-manager*) nil)
    )
  )
(defun add-components-to-filesystem (name path)
  #+debug (format t "add component to filesystem: ~a ~a~%" name path)
  (let* ((project (find-project name path))
	 (component-value-comment (component-value-and-comment project))
	 (directory (concatenate-string-with-path-sep path name))
	 )
    #+debug (print directory)
    #+debug (format t "~a ~a ~%" directory component-value-comment) 
    (dolist (c component-value-comment)
      (if (not (contain-name-in-directory? (car c) directory))
	  (create-directory (concatenate-string-with-path-sep directory (car c)))
	)
      )
    )
  )
(defun add-to-filesystem (name path)
  (let ((exist-path? (directory-exist-p path)))
    (if (not exist-path?) (create-directory path))
    (let ((name-exist? (contain-name-in-directory? name path)))
      (if (not name-exist?) (create-directory (concatenate-string-with-path-sep path name)))
      (add-components-to-filesystem name path)
      )
    )
  )
(defmacro deftest (before assert after)
  "
    form : (deftest (before-form*) (assert-form*) (after-form*)
  "
;;  `(progn ,@before ,@(mapcar #'(lambda (a) `(progn `(format t "test ~a~%" ,a) `(assert ,a))) assert) ,@after)
  `(progn ,@before ,@(mapcar #'(lambda (a) (list 'progn  `(format t "test : ~a~%" ',a) `(assert ,a) )) assert) ,@after)

  )