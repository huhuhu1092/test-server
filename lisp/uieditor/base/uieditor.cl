(in-package :uie)
(defconstant *component-define* '((:element "element" "this is for element directory")
				  (:image "image" "this is for image directory")
				  (:imagetable  "imagetable" "this is for image table directory")
			          (:effect "effect" "this is for effect directory")
				  (:action "action" "this is for action directory")
				  (:statetable "statetable" "this is for state table directory")))
(defvar *projects* nil)
(defstruct project name path components)
(defstruct component
  dirname ;;dirname is keyword value
  dirvalue ;;dirvalue is string
  items
  comment ;;this component's usage  
  )
(defun component-define-name (cd)
  (car cd)
  )
(defun component-define-value (cd)
  (cadr cd)
  )
(defun component-define-comment (cd)
  (caddr cd)
  )

(defun create-project-component ()
  (mapcar #'(lambda (cd) (make-component :dirname (component-define-name cd)
					:dirvalue (component-define-value cd)
					:items nil
					:comment (component-define-comment cd)))
	  *component-define*)
  )

(defun add-project (name path)
  (when (is-contain-project-name name) (error "project's name has contained"))
  (when (is-contain-project-path path) (error "project's path has contained"))
  (let ((project (make-project :name name :path path :components (create-project-component)))) 
    (pushnew project *projects*)
    )
  )
(defun delete-project (name)
  (let ((p (remove-if #'(lambda (p) (string-equal (project-name p) name)) *projects*)))
    (setf *projects* p)
    )
  )

(defun list-project ()
  (copy-list *projects*)
  )
;;(defun is-contain-project-name (name)
;;  (mapcar #'(lambda (p) (if (string-equal (project-name p) name) p nil)) *projects*)
;;  )
(defun is-contain-project-name (name)
  (dolist (p *projects*)
    (if (string= (project-name p) name) (return-from is-contain-project-name t))
    )
  nil
  )
(defun is-contain-project-path (path)
  (dolist (p *projects*)
    (if (string= (project-path p) path) (return-from is-contain-project-path t))
    )
  nil
  )
(defun list-project-name ()
  (let ((name nil))
    (dolist (p *projects*)
      (push (project-name p) name)
      )
    name
    )
  )
(defun list-project-path ()
  (let ((path nil))
    (dolist (p *projects*)
      (push (project-path p) path)
      )
    path
    )
  )
(defun project-num ()
  (length *projects*)
  )

